#! /usr/bin/env python3

# corpus-configs-json2yaml
#
# Convert Korp corpus configurations from frontend JavaScript
# (stringified to JSON) to backend YAML.
#
# Usage: corpus-configs-json2yaml input.json [outputdir]
#
# input.json is a JSON file containing the representation of a
# JavaScript object combining the following objects in the Korp
# frontend: settings, attrs, sattrs, attrlist, sattrlist, options,
# within, transl, loc_data. They can be converted to JSON in the
# browser's JavaScript console as follows, for example:
#
#   data = {}
#   for (let prop of "settings attrs sattrs attrlist sattrlist options context within transl loc_data".split(" ")) {
#       data[prop] = window[prop]
#   }
#   s = JSON.stringify(data)
#
# Default outputdir is "./yaml".


# TODO:
# - Handle multiple modes (separate JSON files), combining common corpora
# - Handle common values of attribute lists
# - Extract common values of attributes etc. without an explicit value in
#   attrs etc.


import json
import os
import os.path
import re
import sys

import yaml


class KorpCorpusConfigConverter:

    """Convert Korp corpus configurations from JavaScript/JSON to YAML.
    """

    # Directories for common values of attributes and others
    common_values_dirs = {
        "attrs": "attributes/positional",
        "sattrs": "attributes/structural",
        "options": "options",
        "context": "contexts",
        "within": "withins",
        "transl": "translations",
    }
    # Subdirectories to be created under output directory
    subdirs = [
        "modes",
        "corpora",
    ] + list(common_values_dirs.values())
    # Corpus folder properties that are not subfolders
    nonfolder_props = [
        "title",
        "description",
        "contents",
        "info",
    ]
    # Language code mapping from two-letter to three-letter ones
    lang_map = {
        "en": "eng",
        "fi": "fin",
        "sv": "swe",
    }
    # Property name mapping
    prop_map = {
        "attributes": "pos_attributes",
    }
    # Properties to be removed (from the top level)
    remove_props = [
        "corpusType",
        "linkAttributes",
        "logicalCorpus",
        "private_struct_attributes",
        "time",
    ]
    # Attribute list properties
    attrlist_props = [
        "pos_attributes",
        "struct_attributes",
        "custom_attributes",
    ]
    # Corpus object properties whose values are to be replaced with
    # the key in the common values of the property with an equal
    # value. Values in the list are pairs (property_path, values_obj),
    # where property_path is a dot-separated path of unconverted
    # property names in settings.corpora.*, where * denotes any key,
    # and values_obj is the key in the in input JSON under which equal
    # values are searched.
    corpus_common_value_replace_rules = [
        ("attributes.*", "attrs"),
        ("structAttributes.*", "sattrs"),
        ("attributes.*.opts", "options"),
        ("structAttributes.*.opts", "options"),
        ("customAttributes.*.opts", "options"),
        ("context", "context"),
        ("within", "within"),
        ("attributes.*.translation", "transl"),
        ("structAttributes.*.translation", "transl"),
        ("customAttributes.*.translation", "transl"),
    ]
    # Replace rules for common values: a list of pairs (common_values,
    # rules), where common_values is a list of keys for common-value
    # objects and rules is a list of pairs as above in
    # corpus_common_value_replace_rules.
    common_values_replace_rules = [
        (["attrs", "sattrs"],
         [
             ("opts", "options"),
             ("translation", "transl"),
         ]),
    ]
    # Output property order (in various kinds of mapping objects);
    # non-listed keys come after the listed ones
    # TODO: Add more keys
    prop_order = [
        "id",
        "label",
        "title",
        "description",
        "subfolders",
        "lang",
        "linked_to",
        "metadata_urn",
        "urn",
        "cite_id",
        "shortname",
        "iprholder",
        "limited_access",
        "licence",
        "licence_type",
        "context",
        "within",
        "pos_attributes",
        "struct_attributes",
        "custom_attributes",
    ]

    def __init__(self):
        """Initialize instance attributes"""
        # Input data read from JSON
        self._indata = None
        # Data to be output as YAML
        self._outdata = {}
        # Output directory
        self._outdir = None
        # Name of the mode
        self._modename = ""
        # The folder for each corpus
        self._corpus_folder = {}
        # Attributes actually used (in attrs and sattrs)
        self._replaced_values = dict(
            [(name, set())
             for _, name in self.corpus_common_value_replace_rules])

    def main(self, args):
        """Main method"""
        self._read_json(args[0])
        self._convert_config()
        self._outdir = args[1] if len(args) > 1 else "yaml"
        self._write_config()

    def _read_json(self, fname):
        """Read input JSON from file named fname"""
        with open(fname, "r") as f:
            self._indata = json.load(f)

    def _convert_config(self):
        """Convert the configuration in self._indata to self._outdata"""
        self._convert_mode()
        self._convert_corpora()
        self._convert_common_values()

    def _convert_mode(self):
        """Generate mode configuration to self._outdata"""
        settings = self._indata["settings"]
        self._modename = settings["mode"]["mode"]
        self._outdata["mode"] = {
            "label": self._get_localized_obj(settings["mode"]["localekey"]),
            "folders": self._make_folder(settings["corporafolders"]),
        }

    def _get_localized_obj(self, key):
        """Return a localized object for localization key key.

        The returned object has the structure
            {
              "lang1": "translation in lang1",
              "lang2": "translation in lang2",
              ...
            }
        """
        loc_data = self._indata["loc_data"]
        result = {}
        for in_lang, out_lang in self.lang_map.items():
            val = loc_data[in_lang].get(key)
            if val is None:
                val = key
            result[out_lang] = val
        return result

    def _make_folder(self, folder, parents=None):
        """Make a output corpus folder object from folder.

        folder may be either the top-level folder object
        (settings.corporafolders) or a subfolder. parents contains the
        names of parent folders, separated by dots (and with a leading
        dot).
        """
        parents = parents or ""
        subfolders = {}
        for prop in folder:
            if prop not in self.nonfolder_props:
                subfolders[prop] = self._make_folder(
                    folder[prop], f"{parents}.{prop}")
        for corpus_id in folder.get("contents", []):
            # Drop leading dot from parents
            self._corpus_folder[corpus_id] = parents[1:]
        if "title" in folder:
            # Lower-level folder
            result = {
                "title": folder["title"],
                "description": folder.get("description", ""),
            }
            if subfolders:
                result["subfolders"] = subfolders
            return result
        else:
            # Top-level folder
            return subfolders

    def _convert_corpora(self):
        """Convert settings.corpora"""
        settings = self._indata["settings"]
        self._outdata["corpora"] = {}
        for corpus in settings["corpora"]:
            self._outdata["corpora"][corpus] = self._make_corpus(
                corpus, settings["corpora"][corpus])

    def _make_corpus(self, corpus_id, corpus_obj):
        """Make output corpus object for corpus_obj with id corpus_id"""
        result = corpus_obj
        result = self._replace_common_values(
            result, self.corpus_common_value_replace_rules)
        result = self._convert_keys(result, 3)
        result = self._convert_lang_codes(result)
        result = self._convert_attrs(result)
        for key in ["context", "within"]:
            result[key] = self._convert_context_within(result[key],
                                                       as_list=True)
        result["mode"] = self._make_corpus_mode(corpus_id)
        return result

    def _convert_keys(self, obj, levels):
        """Convert dict keys (property names) in obj, up to depth levels"""

        def snake_case(key):
            """Convert key from camelCase to snake_case"""
            return re.sub(r"[A-Z]", lambda mo: "_" + mo.group().lower(), key)

        def convert_key(key):
            """Map key with self.prop_map and convert to snake_case"""
            return self.prop_map.get(key, snake_case(key))

        if isinstance(obj, dict):
            return dict((convert_key(key),
                         val if levels <= 1 else self._convert_keys(val,
                                                                    levels - 1))
                        for key, val in obj.items()
                        if key not in self.remove_props)
        else:
            return obj

    def _convert_lang_codes(self, obj, depth=None):
        """Convert language codes in obj.

        If depth is None, convert language codes in subobjects with
        key "translation" in obj. If depth == 0, treat obj as a
        translation object and convert keys directly in it. If depth >
        0, convert translation keys at depth, even if there is no key
        "translation".
        """
        if not isinstance(obj, dict):
            return obj
        elif depth == 0:
            result = {}
            for key, transls in obj.items():
                result[key] = dict((self.lang_map.get(lang, lang), transl)
                                   for lang, transl in transls.items())
            return result
        elif depth is not None and depth > 0:
            return dict((key, self._convert_lang_codes(obj[key], depth - 1))
                        for key in obj)
        else:
            if "translation" in obj and isinstance(obj["translation"], dict):
                obj["translation"] = self._convert_lang_codes(
                    obj["translation"], 0)
            return dict((key, self._convert_lang_codes(obj[key]))
                        for key in obj)

    def _convert_attrs(self, obj):
        """Convert attributes objects in obj from dict to list of dicts"""
        for attrlist_name in self.attrlist_props:
            if attrlist_name in obj:
                obj[attrlist_name] = [
                    dict([(key, val)])
                    for key, val in obj[attrlist_name].items()]
        return obj

    def _convert_context_within(self, obj, as_list=False):
        """Convert a context or within value to a dict with label, value.

        If as_list is True, return the result as a list of values
        instead of a dict.
        """
        if isinstance(obj, str):
            return obj
        for key in obj:
            obj[key] = {
                "label": self._get_localized_obj(key),
                "value": key,
            }
        return list(obj.values()) if as_list else obj

    def _replace_common_values(self, obj, replace_rules):
        """Replace common values in obj according to replace_rules"""

        def replace_values(obj, prop_path, values):
            """Replace values in prop_path in obj if found in values"""
            # print("replace_values", prop_path)
            if len(prop_path) == 1:
                if prop_path[0] == "*":
                    for key in obj:
                        replace_value(obj, key, values)
                elif prop_path[0] in obj:
                    replace_value(obj, prop_path[0], values)
            else:
                if prop_path[0] == "*":
                    prop_path_rest = prop_path[1:]
                    for key in obj:
                        replace_values(obj[key], prop_path_rest, values)
                elif prop_path[0] in obj:
                    replace_values(obj[prop_path[0]], prop_path[1:], values)

        def replace_value(obj, prop_key, values):
            """If obj[prop_key] == values[x] for any x, replace it with x"""
            # print("replace_value", prop_key)
            for key, val in values.items():
                if obj[prop_key] == val:
                    obj[prop_key] = key
                    self._replaced_values[values_name].add(key)
                    return

        for prop_path, values_name in replace_rules:
            values = self._indata.get(values_name)
            if values:
                value_key = replace_values(obj, prop_path.split("."), values)
        return obj

    def _make_corpus_mode(self, corpus_id):
        """Make the value of the "mode" object for corpus corpus_id"""
        result = {
            "name": self._modename,
        }
        if corpus_id in self._corpus_folder:
            result["folder"] = self._corpus_folder[corpus_id]
        # Mode value is a list
        return [result]

    def _convert_common_values(self):
        """Convert the common values elsewhere than in settings"""
        convert_keys_1 = lambda val: self._convert_keys(val, 1)
        convert_funcs = [
            (lambda val: self._convert_keys(val, 1),
             ["attrs", "sattrs"]),
            (self._convert_lang_codes,
             ["attrs", "sattrs"]),
            (lambda val: self._convert_lang_codes(val, 1),
             ["transl"]),
            (self._convert_context_within,
             ["context", "within"]),
        ]
        # First convert the common values similarly to the values in
        # corpus configurations, according to convert_funcs above
        for convert_func, valtypes in convert_funcs:
            for valtype in valtypes:
                self._indata[valtype] = convert_func(
                    self._indata.get(valtype, {}))
        # Then replace common values with the name of value, according
        # to self.common_values_replace_rules
        for targets, rules in self.common_values_replace_rules:
            for target in targets:
                for key, val in self._indata[target].items():
                    self._indata[target][key] = self._replace_common_values(
                        val, rules)

    def _write_config(self):
        """Output the YAML configuration files"""
        self._make_outdirs(self._outdir)
        self._write_yaml(self._outdata["mode"], "modes", self._modename)
        for corpus_id, corpus_data in self._outdata["corpora"].items():
            self._write_yaml(corpus_data, "corpora", corpus_id)
        self._write_common_values()

    def _make_outdirs(self, outdir):
        """Create YAML output directories"""
        os.makedirs(outdir, exist_ok=True)
        for subdir in self.subdirs:
            os.makedirs(os.path.join(outdir, subdir), exist_ok=True)

    def _write_yaml(self, obj, dirname, fname):
        """Write obj as YAML to dirname/fname.yaml"""
        # This is used in the nested class below
        prop_order = self.prop_order

        class ReorderMappingYAMLDumper(yaml.Dumper):

            """yaml.Dumper subclass reordering mappings

            The subclass reorders mapping keys, so that keys listed in
            prop_order come first, in that order.
            """

            # Ordering dict mapping key values to sort keys based on
            # list prop_order; assumes at most 99 items in prop_order
            _key_order = dict([(key, "{:02d}".format(i) + key)
                               for i, key in enumerate(prop_order)])

            def represent_mapping(self, tag, mapping, flow_style=None):
                """Return yaml.MappingNode with mapping keys reordered"""

                def sortkey(val):
                    return self._key_order.get(val[0].value, f"99{val}")

                node = super().represent_mapping(tag, mapping, flow_style)
                node = yaml.MappingNode(
                    node.tag, sorted(node.value, key=sortkey),
                    node.flow_style, node.start_mark, node.end_mark)
                return node

        with open(os.path.join(self._outdir, dirname, fname + ".yaml"),
                  "wb") as f:
            yaml.dump(obj, f, default_flow_style=False, encoding="utf-8",
                      allow_unicode=True, Dumper=ReorderMappingYAMLDumper)

    def _write_common_values(self):
        """Write the common values used somewhere to files"""
        for values_key, values_dir in self.common_values_dirs.items():
            for key in self._replaced_values[values_key]:
                self._write_yaml(
                    self._indata[values_key][key], values_dir, key)


if __name__ == "__main__":
    KorpCorpusConfigConverter().main(sys.argv[1:])
